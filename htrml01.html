━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
扩展知识



━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
window 对象



版本更新
2019-06-20(星期四) - Commits on Mar 23, 2019

文章地址
https://github.com/wangdoc/javascript-tutorial/blob/master/docs/bom/window.md
https://wangdoc.com/javascript/bom/window.html

目录列表
01. 概述
02. window 对象的属性
	02.01. window.name
	02.02. window.closed，window.opener
	02.03. window.self，window.window
	02.04. window.frames，window.length
	02.05. window.frameElement
	02.06. window.top，window.parent
	02.07. window.status
	02.08. window.devicePixelRatio
	02.09. 位置大小属性
	02.10. 窗口组件属性
	02.11. 全局对象属性
	02.12. window.isSecureContext
03. window 对象的方法
	03.01. window.alert()，window.prompt()，window.confirm()
	03.02. window.open(), window.close()，window.stop()
	03.03. window.moveTo()，window.moveBy()
	03.04. window.resizeTo()，window.resizeBy()
	03.05. window.scrollTo()，window.scroll()，window.scrollBy()
	03.06. window.print()
	03.07. window.focus()，window.blur()
	03.08. window.getSelection()
	03.09. window.getComputedStyle()，window.matchMedia()
	03.10. window.requestAnimationFrame()
	03.11. window.requestIdleCallback()
04. 事件
	04.01. load 事件和 onload 属性
	04.02. error 事件和 onerror 属性
	04.03. window 对象的事件监听属性
05. 多窗口操作
	05.01. 窗口的引用
	05.02. iframe 元素
	05.03. window.frames 属性



━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
01. 概述



浏览器里面，window 对象（注意，w 为小写）指当前的浏览器窗口。
它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。

一个变量如果未声明，那么默认就是顶层对象的属性。
下面代码中，a 是没有声明就直接赋值的变量，它自动成为顶层对象的属性。
但是严格模式下，不允许这样创建全局属性或方法，只能用明文写 window.variableName 的形式创建。
<script>
a = 1;								// 相当于 window.a = 1;
console.log( window.a );			// 1
(function(){'use strict';			// 严格模式
	window.b = 2;					// 得加上 window 前缀
	console.log( b );				// 2
	try{ c = 2 }					// 不能这样创建全局变量
	catch(e){ console.log(e) };		// 报错 : ReferenceError: c is not defined
})();
</script>

window 有自己的实体含义，其实不适合当作最高一层的顶层对象，这是一个语言的设计失误。
最早，设计这门语言的时候，原始设想是，语言内置的对象越少越好，这样可以提高浏览器的性能。
因此 Brendan Eich 把 window 当作顶层对象，所有未声明就赋值的变量都自动变成 window 对象的属性。
这种设计使得编译阶段无法检测出未声明变量，但到了今天已经没有办法纠正了。



━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
02. window 对象的属性



02.03. window.self, window.window

window.self 和 window.window 属性都指向窗口本身，这两个属性只读。
<script>
console.log( window.self === window );			// true
console.log( window.window === window );		// true
</script>



02.06. window.parent, window.top

window.parent 属性指向父窗口，如果当前窗口没有父窗口，window.parent 指向自身。
window.top 属性指向最顶层窗口，主要用于在框架窗口（frame）里面获取顶层窗口。
如果当前页面并不是作为其他页面的子页面，那么这两个属性等同于 window 对象。
<iframe id="iframe01" src="html02.html"></iframe>
<script>
console.log( window.parent === window );									// true
console.log( window.top === window );										// true
var iframe01Window = document.getElementById('iframe01').contentWindow;		// 获取 iframe 标签的 window 对象
console.log( iframe01Window.parent === window );							// true
console.log( iframe01Window.top === window );								// true
</script>



02.04. window.length, window.frames

window.length 属性返回当前网页包含的框架总数。
如果当前网页不包含 iframe 或 frame 元素，那么 window.length 就返回 0。

window.frames 属性其实是页面的 window 对象的别名，也就是说 window.frames === window;
但 window.frames 属性可以使用中括号加数值，代表成员为页面内所有框架窗口，包括 iframe/frame 元素，window.frames[0] 表示页面中第一个框架窗口。

◆一般来讲如果为标签设置了 id 属性，那么在全局中就会出现该 id 属性值的变量，这个个元素节点。
◆例如说我们有个 div 标签，该标签的 id="div01"，那么全局中就会出现一个 div01 的变量，就代表这个 div01 节点。
◆但 iframe 标签比较特殊，如果为 iframe 标签设置了 id 属性，在全局中出现的同 id 值的变量，在 Firefox 和 Chrome 中它是个标签节点。
◆但在 IE 中却代表 iframe 标签的 window 对象，所以得用 document.getElementById() 等方法选择 iframe 节点，不能用全局中自动生成的 id 同名变量。
<iframe id="iframe01" src="html02.html"></iframe>
<script>
window.onload = function(){
	// window.frames 属性和 window.length 属性
	console.log( window.frames );								// Window html01.html
	console.log( window.frames === window );					// true # window.frames 其实就是等于 window
	console.log( window.length );								// 1 # 如果页面中没有 iframe 也没有 frame，那么 window.length 就等于 0
	console.log( window.length === window.frames.length );		// true # 因为 window.frames 就等于 window，所以这两个比对的属性值就是同一个
	// window.frames 属性的元素都是 window
	console.log( window.frames[0] );							// Window html02.html # 这样获取的是 iframe01 的 window
	console.log( window.frames[0].location.href );				// http://192.168.1.199:8041/99-test/html02.html # iframe01 的地址
	console.log( window[0] );									// Window html02.html # 这样获取的是 iframe01 的 window
	console.log( window[0].location.href );						// http://192.168.1.199:8041/99-test/html02.html # iframe01 的地址
	// 在全局中自动生成的标签 id 值变量
	console.log( iframe01 );									// Firefox & Chrome 是 HTMLIframeElement，IE 是 Window html02.html
	console.log( iframe01.contentWindow );						// Firefox & Chrome 是 Window html02.html，IE 是 undefined
	// 原生 JS 操作 iframe 标签
	var iframe01Ele = document.getElementById('iframe01');		// 必须要用选择方法选择标签，不能拿全局中自动生成的对象
	console.log( iframe01Ele );									// HTMLIFrameElement
	console.log( iframe01Ele.contentWindow );					// Window html02.html 
	console.log( iframe01Ele.contentDocument  );				// Document html02.html
	// jQuery 操作 iframe 标签
	console.log( $('#iframe01').contents() );					// Object[Document html02.html]
	console.log( $('#iframe01').contents().find('head') );		// Object[head]
};
</script>



02.05. window.frameElement

window.frameElement 属性返回页面所在的标签（可能是 iframe 或 object 或 embed 元素节点）。
如果当前窗口是顶层窗口，并不是其他页面的子页面，或者所嵌入的那个网页不是同源的，则该属性返回 null。
<iframe id="iframe01" src="html02.html"></iframe>
<script>
var iframe01Window = document.getElementById('iframe01').contentWindow;
console.log( iframe01Window.frameElement );												// <iframe id="iframe01" src="html02.html">
console.log( iframe01Window.frameElement === document.getElementById('iframe01') );		// true
</script>



02.01. window.name

window.name 属性是一个字符串，表示当前浏览器窗口的名字。
窗口的名字不是必须的，该属性主要是配合 a/form 标签的 target 属性使用。

该属性只能保存字符串，如果值不是字符串，会自动转成字符串。
各个浏览器对这个属性值的储存容量有所不同，但是一般来说，可以高达几 MB。

◆只要浏览器窗口不关闭，window.name 属性就不会消失，例如访问 a.com 时，该页面的脚本设置了 window.name。
◆接下来在同一个窗口里面载入了 b.com，新页面的脚本可以读到上一个网页设置的 window.name。
◆页面刷新后 window.name 属性还在的，但在窗口关闭后，该属性保存的值就会消失，因为这时窗口已经不存在了。

◆a 标签点击后 iframe 标签发生跳转，需要 a 标签的 target 属性值和 iframe 标签的 name 属性保持一致。
◆而 iframe 标签上的 name 属性值，也会成为 iframe 标签的 contwntWindow.name 属性的返回值。
◆window.name 属性是可读写的，但是修改后 iframe 标签上的 name 属性并不会跟着变化。
◆但 a 标签的点击跳转，就不再生效了，因为 target 属性和 name 属性对应不上了。

下例中，一旦修改了 window.name，再点击 a 标签，iframe 标签不会再响应，此时会打开新窗口。
因为 a 标签的 target 属性值和 iframeWindow.name 再也对不上了，所以就不在 iframe01 中响应了。
<a href="html02.html" target="iframe01">点击会刷新 iframe 标签</a><br />
<iframe id="iframe01" name="iframe01" src="html02.php"></iframe><br />
<button id="button01" type="button">点击修改 window.name 属性</button>
<script>
button01.addEventListener('click', function(){
	iframe01Window.name = 'customName'
	console.log( iframe01Window.name );		// customName
}, false);
var iframe01Window = document.querySelector('iframe').contentWindow;
console.log( iframe01Window.name );		// iframe01
</script>



02.02. window.opener

window.opener 属性表示打开当前窗口的父窗口。
如果当前窗口并没有父窗口（当前窗口是直接在地址栏输入打开），则返回 null。
浏览器可能会阻止 window.open() 方法打开的新窗口，阻止后 newWindow 就会是 null，所以使用返回值得先判断一下。
<script>
var newWindow = window.open('html02.html', 'newWindow', 'width=320,height=320,left=0;top=0');
if( newWindow ){
	console.log( newWindow );						// Window about:blank
	console.log( newWindow.name );					// newWindow
	console.log( newWindow.opener === window );		// true
};
console.log( window.opener );						// null # 如果当前窗口是用 url 进入的，则 window.opener 属性为 null（IE9 为 undefined）
</script>

通过 opener 属性，可以获得父窗口的全局属性和方法，但只限于两个窗口同源的情况（参见《同源限制》一章），且其中一个窗口由另一个打开。
为 a 标签添加 rel="noopener" 属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。
该属性 IE 和 Edge 不支持（Edge76 开始支持），Firefox52+/Chrome49+ 支持。
<!-- a 标签放在 html01.html 中-->
<a href="html02.html" target="_blank">通过这个标签打开的页面具有 window.opener 属性</a><br />
<a href="html02.html" target="_blank" rel="noopener">通过这个标签打开的页面没有 window.opener 属性</a>
<!-- script 标签放在 html02.html 中-->
<script>
console.log( window.opener );		// Window html01.html
if(window.opener){ window.opener.alert('恶意代码') };
</script>

如果两个窗口之间不需要通信，建议将子窗口的 opener 属性显式设为 null，这样可以减少一些安全隐患。
下面代码中，子窗口的 opener 属性设为 null，两个窗口之间就没办法再联系了。
<script>
var newWindow = window.open('example.html', 'newWindow', 'height=320,width=320,left=0;top=0');
if(newWindow){ newWin.opener = null };
</script>



02.02. window.closed

window.closed 属性返回一个布尔值，表示窗口是否关闭。
检查当前窗口是否关闭没什么意义，因为只要能运行代码，当前窗口肯定没有关闭。
所以这个属性一般是用来检查，使用脚本打开的新窗口是否已经关闭（一般是用 window.open() 方法打开）。
<script>
var newWindow = window.open('html02.html', 'newWindow', 'width=320,height=320,left=0;top=0');
var si01 = setInterval(function(){
	if( !newWindow ){ clearInterval(si01) }
	else if( newWindow.closed ){ console.log('newWindow 窗口已关闭') }
	else{ console.log('newWindow 窗口打开中') };
}, 500);
</script>



02.07. window.status

window.status 属性用于读写浏览器状态栏的文本。
但是，现在很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。
<script>
console.log( window.status );		// ''
window.status = 'status reset';
console.log( window.status );		// status reset # 但 IE9 依然为空，也就是说无法设置
</script>



02.12. window.isSecureContext

window.isSecureContext 属性返回一个布尔值，表示当前窗口是否处在加密环境。
如果是 HTTPS 协议，就是 true，否则就是 false。
<script>
console.log( window.isSecureContext );		// false
</script>



02.08. window.devicePixelRatio

window.devicePixelRatio 属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率，也就是一个 CSS 像素由多少个物理像素组成。
它可以用于判断用户的显示环境，如果这个比率较大，就表示用户正在使用高清屏幕，因此可以显示较大像素的图片。
<script>
console.log( window.devicePixelRatio );		// 1
</script>
